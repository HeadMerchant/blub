vec2i :: struct {
	x: s32
	y: s32
}

write :: fn(fd: s32, buf: [^]u8, count: usize)

print :: fn(buf: []u8) {
	stdout :: 1
	write(stdout, buf.data, buf.length)
}

print_u32 :: fn(x: u32) {
	zero : [1]u8
	if (x == 0) {
		print(buf[zero[]])
		return
	}
	buf : [10]u8
	i := 9
	y := x
	while (y > 0) {
		digit := y % 10
		y = y / 10
		buf[i] = '0' + @numcast(digit)
		i = i - 1
	}
	print(buf[i..])
}

print_s32 :: fn(x: s32) {
	zero : [1]u8
	if (x == 0) {
		print(buf[zero[]])
		return
	}
	buf : [11]u8
	isNegative := x < 0
	i := 10
	y := if (isNegative) -x else x
	while (y > 0) {
		digit := y % 10
		y = y / 10
		buf[i] = '0' + @numcast(digit)
		i = i - 1
	}
	if (isNegative) {
		buf[i] = '-'
		i = i - 1
	}
	print(buf[i..])
}

vec2 :: struct {
	x: f32
	y: f32

	# dot :: fn (self: ^vec2, other: vec2): float {
	# 	return self.x*other.x + self.y*other.y
	# }
}

# printInt :: fn(x: s32) {
# 	printf(c"%d", x)
# }

# printFloat :: fn(x: f32) {
# 	y := @numCast(x, f64)
# 	printf(c"%f", x)
# }

# printVec2 :: fn(v: ^vec2) {
# 	printf(c"vec2(")
# 	printFloat(v^.x)
# 	printf(c", ")
# 	printFloat(v^.y)
# 	printf(c")\n")
# }

# printVec2I :: fn(v: ^vec2i) {
# 	printf(c"vec2(")
# 	printInt(v^.x)
# 	printf(c", ")
# 	printInt(v^.y)
# 	printf(c")\n")
# }

main :: fn () {
	v := vec2i(5, 4)
	print("Printing works")
	print_s32(v.x)
	# printVec2I(^v)

	v2 := vec2(5, 4)
	# printVec2(^v2)
} 
